#![feature(ptr_offset_from, map_first_last)]

mod bigint;
mod closure_table;
mod crc32;
mod gc;
mod leb128;
mod principal_id;
mod text;
mod utf8;

use motoko_rts::gc_common::collect_internal;
use motoko_rts::types::*;

#[macro_use]
extern crate maplit;

fn main() {
    if std::mem::size_of::<usize>() != 4 {
        println!("Motoko RTS only works on 32-bit architectures");
        std::process::exit(1);
    }

    /*
    let refs = &btreemap! {
        0 => vec![0, 2],
        2 => vec![0],
        3 => vec![3],
    };
    let heap_1 = gc::allocate_heap(&refs);

    println!("{:?}", heap_1);

    // Original heap: [3, 0, 4294967295, 3, 3, 4, 4294967295, 3, 6, 6]

    // New heap: [3, 2, 0]
    #[rustfmt::skip]
    let heap_2: Vec<u32> = vec![
        3, 6, u32::MAX,
        3, 4, 5,
        3, 0, 5, 2,
    ];

    gc::check_heap(&refs, &heap_2, 10);

    unsafe {
        // Convert the word array into a byte array with little-endian encoding
        let mut heap = heap_1.clone();

        // Make sure heap has enough space for copying GC
        heap.reserve(heap.len());

        let heap_slice = unsafe { as_u8_slice(&heap) };
        let heap_ptr = heap_slice.as_ptr();
        let heap_end_ptr = heap_ptr.add(heap.len());

        let mut end_of_gc_hp = 0;

        collect_internal(
            // get_heap_base
            || heap_ptr as u32,
            // get_hp
            || heap_end_ptr as u32,
            // set_hp
            |_hp| {},
            // note_live_size
            |_live_size| {},
            // note_reclaimed
            |_reclaimed| {},
            // get_static_roots
            || todo!(),
            // get_closure_table_loc
            || todo!(),
            // grow_memory
            |_ptr| panic!("grow_memory called"),
        );
    }
    */

    // unsafe {
    //     closure_table::test();
    //     bigint::test();
    //     utf8::test();
    //     crc32::test();
    //     principal_id::test();
    //     text::test();
    //     leb128::test();
    // }
}

unsafe fn as_u8_slice(v: &[u32]) -> &[u8] {
    std::slice::from_raw_parts(
        v.as_ptr() as *const u8,
        v.len() * std::mem::size_of::<u32>(),
    )
}

// Called by the RTS to panic
#[no_mangle]
extern "C" fn rts_trap(_msg: *const u8, _len: Bytes<u32>) -> ! {
    panic!("rts_trap_with called");
}

// Called by RTS BigInt functions to panic. Normally generated by the compiler
#[no_mangle]
extern "C" fn bigint_trap() -> ! {
    panic!("bigint_trap called");
}

// Called by the RTS for debug prints
#[no_mangle]
unsafe extern "C" fn print_ptr(ptr: usize, len: u32) {
    let str: &[u8] = core::slice::from_raw_parts(ptr as *const u8, len as usize);
    println!("[RTS] {}", String::from_utf8_lossy(str));
}
